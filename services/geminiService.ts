// FIX: The `GenerateContentCandidate` type is not exported from `@google/genai`. It has been removed from the import.
import { GoogleGenAI, Type, GenerateContentResponse, Modality, Operation } from '@google/genai';
import { GroundingChunk } from '../types';

// FIX: `GenerateContentCandidate` is defined using an indexed access type on `GenerateContentResponse` for type safety, as it's not exported from the SDK.
type GenerateContentCandidate = GenerateContentResponse['candidates'][number];

const getAiClient = () => new GoogleGenAI({ apiKey: process.env.API_KEY });

// Dashboard Features
export const getInvestorMatches = async (description: string): Promise<any[]> => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-pro',
        contents: `Based on this startup description: "${description}", generate a list of 3 fictional but realistic investor profiles that would be a good match. For each, provide a name, investment focus, and a brief reason why they are a good match.`,
        config: {
            responseMimeType: 'application/json',
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        name: { type: Type.STRING },
                        focus: { type: Type.STRING },
                        reason: { type: Type.STRING },
                    },
                    required: ["name", "focus", "reason"]
                }
            }
        }
    });

    const jsonText = response.text.trim();
    return JSON.parse(jsonText);
};

export const getPitchDeckReview = async (pitch: string): Promise<string> => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-pro',
        contents: `Act as a venture capitalist. Review the following startup pitch and provide constructive feedback. Focus on clarity, market potential, and potential red flags.\n\nPitch:\n${pitch}`
    });
    return response.text;
};

// Creative Studio Features
export const generateImage = async (prompt: string): Promise<string> => {
    const ai = getAiClient();
    const response = await ai.models.generateImages({
        model: 'imagen-4.0-generate-001',
        prompt: prompt,
        config: {
            numberOfImages: 1,
            outputMimeType: 'image/jpeg',
            aspectRatio: '1:1',
        },
    });
    const base64ImageBytes = response.generatedImages[0].image.imageBytes;
    return `data:image/jpeg;base64,${base64ImageBytes}`;
};

export const editImage = async (base64Image: string, mimeType: string, prompt: string): Promise<string> => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
            parts: [
                { inlineData: { data: base64Image, mimeType: mimeType } },
                { text: prompt },
            ],
        },
        config: {
            responseModalities: [Modality.IMAGE],
        },
    });
    const part = response.candidates?.[0]?.content?.parts?.[0];
    if (part?.inlineData) {
        return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
    }
    throw new Error('No image was generated by the model.');
};

export const animateImage = async (base64Image: string, mimeType: string, prompt: string, aspectRatio: '16:9' | '9:16'): Promise<string> => {
    const ai = getAiClient();
    let operation = await ai.models.generateVideos({
        model: 'veo-3.1-fast-generate-preview',
        prompt: prompt || 'Animate this image.', // Prompt is optional for Veo with an image
        image: {
            imageBytes: base64Image,
            mimeType: mimeType,
        },
        config: {
            numberOfVideos: 1,
            resolution: '720p',
            aspectRatio: aspectRatio,
        }
    });

    while (!operation.done) {
        await new Promise(resolve => setTimeout(resolve, 5000));
        operation = await ai.operations.getVideosOperation({ operation: operation });
    }

    const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
    if (!downloadLink) {
        throw new Error('Video generation failed or returned no link.');
    }
    
    const videoResponse = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
    if (!videoResponse.ok) {
        throw new Error('Failed to download the generated video.');
    }
    const videoBlob = await videoResponse.blob();
    return URL.createObjectURL(videoBlob);
};


// Market Research Features
interface GroundedSearchResult {
    text: string;
    sources: GroundingChunk[];
}

const extractSources = (candidate?: GenerateContentCandidate): GroundingChunk[] => {
    return candidate?.groundingMetadata?.groundingChunks?.map(chunk => chunk as GroundingChunk) ?? [];
};

export const getWebSearchResults = async (query: string): Promise<GroundedSearchResult> => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: query,
        config: {
            tools: [{ googleSearch: {} }],
        },
    });
    return {
        text: response.text,
        sources: extractSources(response.candidates?.[0])
    };
};

export const getLocalSearchResults = async (query: string): Promise<GroundedSearchResult> => {
    const ai = getAiClient();

    const getCoords = (): Promise<{ latitude: number, longitude: number }> => {
        return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
                reject(new Error("Geolocation is not supported by this browser."));
            } else {
                navigator.geolocation.getCurrentPosition(
                    (position) => resolve({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude
                    }),
                    (err) => reject(new Error(`Geolocation error: ${err.message}`))
                );
            }
        });
    };

    const coords = await getCoords();

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: query,
        config: {
            tools: [{ googleMaps: {} }],
            toolConfig: {
                retrievalConfig: { latLng: coords }
            }
        },
    });
    return {
        text: response.text,
        sources: extractSources(response.candidates?.[0])
    };
};

// Content Factory Feature
export const generateContentPiece = async (contentType: 'blog' | 'social' | 'ad', prompt: string): Promise<string> => {
    const ai = getAiClient();
    let finalPrompt = '';

    switch (contentType) {
        case 'blog':
            finalPrompt = `As a professional content marketer, write a compelling and well-structured blog post about "${prompt}". The post should have a catchy title, a short introduction, a body with several paragraphs using markdown for formatting (like headers and lists), and a concluding paragraph. The tone should be informative and engaging for a startup and tech audience.`;
            break;
        case 'social':
            finalPrompt = `As a social media manager for a startup, create three distinct social media posts for different platforms (LinkedIn, Twitter, Instagram) about "${prompt}". For LinkedIn, be professional. For Twitter, be concise and use relevant hashtags. For Instagram, write an engaging caption that could accompany an image. Use markdown to separate the posts clearly.`;
            break;
        case 'ad':
            finalPrompt = `As an expert copywriter, generate three different versions of ad copy for a digital campaign about "${prompt}". Each version should have a compelling headline and a short body text. The goal is to drive clicks and conversions. Format the output clearly using markdown.`;
            break;
    }

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-pro',
        contents: finalPrompt
    });
    return response.text;
};